using System;
using System.Collections;
using System.Collections.Generic;
using System.Numerics;
using System.Reflection;
using System.Runtime.CompilerServices;
using Frosty.Sdk.IO;
using Frosty.Sdk.Utils;
using FrostyDataStreamUtils;
using FrostyMeshPlugin.Gltf.AutoGenerated;
using FrostyMeshPlugin.Utils;
using Buffer = FrostyMeshPlugin.Gltf.AutoGenerated.Buffer;

namespace FrostyMeshPlugin.Gltf;

public class GltfContainer : Container
{
    public override CoordinateSystem CoordinateSystem { get; } = new() { Up = "Y", Forward = "Z", Right = "-X" };
    public override UvSystem UvSystem { get; } = new() { Up = "-Y", Right = "X" };

    public override void Load(string inPath)
    {
        throw new NotImplementedException();
    }

    public override void Save(string inPath)
    {
        AutoGenerated.Gltf gltf = new();

        gltf.Asset = new Asset
        {
            Version = "2.0",
            Generator = "libXXX"
        };

        List<Node> nodes = new();
        List<Scene> scenes = new();
        List<AutoGenerated.Mesh> meshes = new();
        List<Buffer> buffers = new();
        List<BufferView> bufferViews = new();
        List<Accessor> accessors = new();
        List<Material> materials = new();

        Block<byte> buffer = new(0);
        using (BlockStream stream = new(buffer, true))
        {
            Scene scene = new();
            List<int> sceneNodes = new();
            foreach (Model model in Models)
            {
                Node modelNode = new() { Name = model.Name };
                sceneNodes.Add(nodes.Count);
                nodes.Add(modelNode);
                List<int> subNodes = new();

                foreach (Mesh mesh in model.Meshes)
                {
                    Node meshNode = new()
                    {
                        Name = mesh.Name,
                        Mesh = meshes.Count
                    };
                    subNodes.Add(nodes.Count);
                    nodes.Add(meshNode);

                    AutoGenerated.Mesh gltfMesh = new() { Name = mesh.Name };

                    MeshPrimitive primitive = new()
                    {
                        Mode = (MeshPrimitive.ModeEnum)mesh.PrimitiveType,
                        Material = materials.Count
                    };
                    primitive.Attributes ??= new Dictionary<string, int>();

                    materials.Add(new Material(){Name = mesh.Name});

                    if (mesh.Indices.Count > 0)
                    {
                        primitive.Indices = accessors.Count;
                        Accessor accessor = new()
                        {
                            BufferView = bufferViews.Count,
                            ComponentType = Accessor.ComponentTypeEnum.UNSIGNED_INT,
                            Count = mesh.Indices.Count,
                            Type = Accessor.TypeEnum.SCALAR
                        };
                        accessors.Add(accessor);

                        BufferView bufferView = new()
                        {
                            Buffer = buffers.Count,
                            ByteOffset = (int)stream.Position,
                            Target = BufferView.TargetEnum.ELEMENT_ARRAY_BUFFER
                        };
                        bufferViews.Add(bufferView);

                        foreach (uint index in mesh.Indices)
                        {
                            stream.WriteUInt32(index);
                        }
                        bufferView.ByteLength = (int)(stream.Position - bufferView.ByteOffset);
                    }

                    if (mesh.Positions.Count > 0)
                    {
                        primitive.Attributes.Add("POSITION", accessors.Count);
                        Accessor accessor = new()
                        {
                            BufferView = bufferViews.Count,
                            ComponentType = Accessor.ComponentTypeEnum.FLOAT,
                            Count = mesh.Positions.Count,
                            Type = Accessor.TypeEnum.VEC3
                        };
                        accessors.Add(accessor);

                        BufferView bufferView = new()
                        {
                            Buffer = buffers.Count,
                            ByteOffset = (int)stream.Position,
                            Target = BufferView.TargetEnum.ARRAY_BUFFER
                        };
                        bufferViews.Add(bufferView);

                        float xMin = float.MaxValue, xMax = float.MinValue, yMin = float.MaxValue, yMax = float.MinValue, zMin = float.MaxValue, zMax = float.MinValue;
                        foreach (Vector3 position in mesh.Positions)
                        {
                            xMin = Math.Min(xMin, position.X);
                            xMax = Math.Max(xMax, position.X);
                            yMin = Math.Min(yMin, position.Y);
                            yMax = Math.Max(yMax, position.Y);
                            zMin = Math.Min(zMin, position.Z);
                            zMax = Math.Max(zMax, position.Z);

                            // write to buffer
                            stream.WriteVector3(position);
                        }

                        accessor.Min = [xMin, yMin, zMin];
                        accessor.Max = [xMax, yMax, zMax];
                        bufferView.ByteLength = (int)(stream.Position - bufferView.ByteOffset);
                    }

                    if (mesh.Normals.Count > 0)
                    {
                        primitive.Attributes.Add("NORMAL", accessors.Count);
                        Accessor accessor = new()
                        {
                            BufferView = bufferViews.Count,
                            ComponentType = Accessor.ComponentTypeEnum.FLOAT,
                            Count = mesh.Normals.Count,
                            Type = Accessor.TypeEnum.VEC3
                        };
                        accessors.Add(accessor);

                        BufferView bufferView = new()
                        {
                            Buffer = buffers.Count,
                            ByteOffset = (int)stream.Position,
                            Target = BufferView.TargetEnum.ARRAY_BUFFER
                        };
                        bufferViews.Add(bufferView);

                        foreach (Vector3 normal in mesh.Normals)
                        {
                            // write to buffer
                            stream.WriteVector3(normal);
                        }
                        bufferView.ByteLength = (int)(stream.Position - bufferView.ByteOffset);
                    }

                    if (mesh.Tangents.Count > 0)
                    {
                        primitive.Attributes.Add("TANGENT", accessors.Count);
                        Accessor accessor = new()
                        {
                            BufferView = bufferViews.Count,
                            ComponentType = Accessor.ComponentTypeEnum.FLOAT,
                            Count = mesh.Tangents.Count,
                            Type = Accessor.TypeEnum.VEC4
                        };
                        accessors.Add(accessor);

                        BufferView bufferView = new()
                        {
                            Buffer = buffers.Count,
                            ByteOffset = (int)stream.Position,
                            Target = BufferView.TargetEnum.ARRAY_BUFFER
                        };
                        bufferViews.Add(bufferView);

                        for (int i = 0; i < mesh.Tangents.Count; i++)
                        {
                            Vector3 tangent = mesh.Tangents[i];
                            Vector3 binormal = mesh.Binormals[i];
                            Vector3 normal = mesh.Normals[i];

                            // write to buffer
                            stream.WriteVector4(new Vector4(tangent, Vector3.Dot(binormal, Vector3.Cross(normal, tangent)) < 0.0f ? 1.0f : -1.0f));
                        }
                        bufferView.ByteLength = (int)(stream.Position - bufferView.ByteOffset);
                    }

                    for (int i = 0; i < mesh.Uvs.Count; i++)
                    {
                        List<Vector2> uv = mesh.Uvs[i];
                        primitive.Attributes.Add($"TEXCOORD_{i}", accessors.Count);
                        Accessor accessor = new()
                        {
                            BufferView = bufferViews.Count,
                            ComponentType = Accessor.ComponentTypeEnum.FLOAT,
                            Count = uv.Count,
                            Type = Accessor.TypeEnum.VEC2
                        };
                        accessors.Add(accessor);

                        BufferView bufferView = new()
                        {
                            Buffer = buffers.Count,
                            ByteOffset = (int)stream.Position,
                            Target = BufferView.TargetEnum.ARRAY_BUFFER
                        };
                        bufferViews.Add(bufferView);

                        foreach (Vector2 vec in uv)
                        {
                            // write to buffer
                            stream.WriteVector2(vec);
                        }

                        bufferView.ByteLength = (int)(stream.Position - bufferView.ByteOffset);
                    }

                    gltfMesh.Primitives = Set(new List<MeshPrimitive> { primitive });

                    meshes.Add(gltfMesh);
                }

                modelNode.Children = Set(subNodes);
            }

            scene.Nodes = Set(sceneNodes);

            scenes.Add(scene);

            buffers.Add(new Buffer { ByteLength = (int)stream.Length });

            gltf.Scene = 0;
            gltf.Nodes = Set(nodes);
            gltf.Meshes = Set(meshes);
            gltf.BufferViews = Set(bufferViews);
            gltf.Accessors = Set(accessors);
            gltf.Buffers = Set(buffers);
            gltf.Scenes = Set(scenes);
            gltf.Materials = Set(materials);
        }

        Glb.Write(inPath + ".glb", gltf, buffer);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private T? Set<T>(T inList) where T : IList
    {
        if (inList.Count == 0)
        {
            return default;
        }
        return inList;
    }
}